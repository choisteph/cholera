---
title: "Lab Notes: Pearl Strings to Polygons"
author: "lindbrook"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(cholera)
```

## Overview

Two flavors of "expected" area plots: points and polygons

##
```{r area_points, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
plot(neighborhoodWalking(case.set = "expected"), type = "area.points")
```


##
```{r area_polygons, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
plot(neighborhoodWalking(case.set = "expected"), type = "area.polygons")
```

## why polygons?

The virtues of vector graphics.

##
```{r marshall_points, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
streetNameLocator("marshall street", zoom = TRUE)
addNeighborhoodCases(type = "expected")
```


##
```{r marshall_polygons, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
streetNameLocator("marshall street", zoom = TRUE)
addNeighborhoodWalking()
```

## computing polygons

These are the simulated cases within the Broad Street pump neighborhood:

![](cloud-1.png)


The convex hull of those cases:

![](hull-1.png)

To find the points on the perimeter, the candidate points for the vertices of the polygon, I select the point that _do not_ have neighbors at each of the four cardinal directions. See peripheryCases().

![](perimeter-1.png)


To connect the dots, we add pearls to a string to form polygon

![](pearl_string-1.png)


## two algorithms

pearlString() cycles through the candidate points and uses reverse epicycles to find the next point to add to the string of pearls. This is the default for walking neighborhoods.

travelingSalesman() uses the 'TSP' package and its implementation of repetitive nearest neighbors to compute the string of pearls. This is the defaul for euclidean neighbors.

```{r pearl_string, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
neighborhood <- neighborhoodEuclidean(-6, case.set = "expected", vestry = TRUE)

plot(neighborhood, type = "area.polygons", method = "pearl.string")
```

```{r traveling, fig.align = "center", fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE}
neighborhood <- neighborhoodEuclidean(-6, case.set = "expected", vestry = TRUE)

plot(neighborhood, type = "area.polygons", method = "traveling.salesman")
```
