---
title: "Parallelization"
author: "lindbrook"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallelization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">"
)
```

As of version 0.7.0, the 'cholera' package has implemented parallel computation support for Windows via parallel::parLapply(). Previous versions implemented this for macOS and Unix via parallel::mclapply(). 'parallel''s documentation goes to great length to discourage the use of these functions interactively:

> Note that although some precautions are taken in R.app on macOS, the developers of the 'parallel' package, which \code{neighborhoodWalking()} uses, strongly discourage against using parallelization within a GUI or embedded environment.

That said, with more recent versions of 'parallel', I have not experienced significant problems other than those due to coding issues.

neighborhoodWalking()  | 1 logical core | 8 logical cores
------------- | ------------- | -------------
plot.walking() | 4.5  | 3.8
plot.walking(case.set = "expected", type = "road") | 25.9  | 10.3
plot.walking(case.set = "expected", type = "area.points") | 25.9  | 10.6
plot.walking(case.set = "expected", type = "area.polygons") | 52.4  | 18.9

neighborhoodEuclidean  | 1 logical core | 8 logical cores
------------- | ------------- | -------------
plot.euclidean() | 3.6  | 1.3
plot.euclidean(case.set = "expected", type = "road") | 109.1  | 28.5
plot.euclidean(case.set = "expected", type = "area.points") | 108.6  | 27.5
plot.euclidean(case.set = "expected", type = "area.polygons") | 125.7  | 45.7

function  | 1 logical core | 8 logical cores
------------- | ------------- | -------------
simulateFatalities() | 5280.5  | 1228.3
unstackFatalities() | 163.3  | 39.5
simulateWalkingDistance() | 204.5  | 57.9
nearestPump() | 2.4  | 1.8
nearestPump(metric = "euclidean") | 3.1  | 1.0
nearestPump(case.set = "expected") | 347.8  | 92.7
nearestPump(metric = "euclidean", case.set = "expected") | 106.1  | 25.8


## mclapply() v. parLapply()

In theory, my understanding is that computational performance is better with mclapply() than with parLapply() due to greater overhead for the latter. With some exceptions, I have found this to be true (on macOS). This has some implications for programming: you can more easily apply mclapply() to more finely grained problems whereas parLapply() shows benefits for larger tasks.
