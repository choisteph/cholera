---
title: "Parallelization"
author: "lindbrook"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallelization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">"
)
```

'cholera' supports parallelization via parallel::mclapply(), for macOS and Unix, and via parallel::parLapply(), for Windows.

By default, for reasons discussed below, parallelization is turned off. For functions that support it, to enable it you need only set "multi.core = TRUE". You can also pass a value for the number of logical cores to use. To avoid paging to disk, you'd benefit from having adequate RAM: 16 GB is more than adequate for functions in this package.

Note that the 'parallel' package's documentation goes to great length to discourage the use of these functions interactively:

> Note that although some precautions are taken in R.app on macOS, the developers of the 'parallel' package, which neighborhoodWalking() uses, strongly discourage against using parallelization within a GUI or embedded environment. That said, with more recent versions of 'parallel', I only rarely experience crashes. But to be safe, I've set "multi.core = FALSE".

## Benchmark timings

The timings below (in seconds) including those for parallel:parLapply(), which are used to support parallelization on Window, were done on a 2.3 Ghz Intel Core i7 using R version 3.6.1 on macOS 10.14.6.

### parallel::mclapply()

| neighborhoodWalking() | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
plot.walking() | 4.5 | 3.8
plot.walking(case.set = "expected", type = "road") | 26 | 10
plot.walking(case.set = "expected", type = "area.points") | 26 | 11
plot.walking(case.set = "expected", type = "area.polygons") | 52 | 19

| neighborhoodEuclidean() | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
plot.euclidean() | 3.6 | 1.3
plot.euclidean(case.set = "expected", type = "road") | 109 | 28
plot.euclidean(case.set = "expected", type = "area.points") | 109 | 28
plot.euclidean(case.set = "expected", type = "area.polygons") | 126 | 46

| function | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
nearestPump() | 2.4 | 1.8
nearestPump(metric = "euclidean") | 3.1 | 1.0
nearestPump(case.set = "expected") | 348 | 93
nearestPump(metric = "euclidean", case.set = "expected") | 106 | 26
simulateFatalities() | 5280 | 1228
unstackFatalities() | 163 | 40
simulateWalkingDistance() | 204 | 58

### parallel::parLapply()

neighborhoodWalking() | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
plot.walking() | 5.9  | 11.6
plot.walking(case.set = "expected", type = "road") | 26 | 29
plot.walking(case.set = "expected", type = "area.points") | 29 | 34
plot.walking(case.set = "expected", type = "area.polygons") | 55 | 46

> Note that due to its performance, parallelization is not automatically enabled on Windows for neighborhoodWalking(). If you want to use it, you need to set dev.mode = TRUE.

| neighborhoodEuclidean() | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
plot.euclidean() | 4.2 | 3.7
plot.euclidean(case.set = "expected", type = "road") | 108 | 32
plot.euclidean(case.set = "expected", type = "area.points") | 107 | 31
plot.euclidean(case.set = "expected", type = "area.polygons") | 124 | 48

| function | 1 logical core | 8 logical cores
:------------- | -------------: | -------------:
nearestPump() | 3.6 | 9.6
nearestPump(metric = "euclidean") | 3.8  | 3.3
nearestPump(case.set = "expected") | 345 | 96
nearestPump(metric = "euclidean", case.set = "expected") | 106 | 29
simulateFatalities() | 5116 | 1273
unstackFatalities() | 164 | 50
simulateWalkingDistance() | 200 | 73

> Note that due to its performance, parallelization is not automatically enabled on Windows for nearestPump(metric = "walking", case.set = "observed"). If you want to use it, you need to set dev.mode = TRUE.

## Note on mclapply() v. parLapply()

My understanding is that due to greater overhead, mclapply() generally outperforms parLapply(). Related to to this, I found that that in contrast to parLapply(), I was more likely to see benefits from using mclapply() especially when applied to finely grained tasks (smaller chunks of code). This has two implications: first, it made the code less easily portable to Windows; second, it opens up the possibility of future optimization.
